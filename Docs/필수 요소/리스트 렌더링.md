# 리스트 렌더링

## v-for로 엘리먼트에 배열 매핑하기

v-for 디렉브를 사용하여 배열을 기반으로 리스트를 렌더링할 수 있다.  
v-for 디렉티브는 item in items 형태로 특별한 문법이 필요하다.  
여기서 items는 원본 데이터 배열이고 item은 반복되는 배열 엘리먼트의 **별칭**이다.

v-for 블록 안에는 부모 범위 속성에 대한 모든 권한이 있다.  
v-for는 또한 현재 항목의 인덱스에 대한 두 번째 전달인자 옵션을 제공한다.

in 대신에 of를 구분자로 사용할 수 있다.

## v-for와 객체

v-for를 사용하여 객체의 속성을 반복할 수도 있다.

키에 대한 두 번째 전달 인자를 제공할 수도 있다.

인덱스도 제공한다.

## 상태 유지

Vue가 v-for에서 렌더링된 엘리먼트 목록을 갱신할 때 기본적으로 "in-place patch" 전략을 사용한다.  
데이터 항목의 순서가 변경된 경우 항목의 순서와 일치하도록 DOM 요소를 이동하는 대신 Vue는 각 요소를 적절한 위치에 패치하고 해당 인덱스에서 렌더링할 내용을 반영하는지 확인한다.

이 기본 모드는 효율적이지만 목록의 출력 결과가 하위 컴포넌트 상태 또는 임시 DOM 상태에 의존하지 않는 경우에 적합하다.

각 노드의 id를 추적하여, 재사용하거나 순서를 변경하는 등의 작업을 위해 각 아이템에 유일한 key 속성을 주어, vue에게 힌트를 줄 수 있다.

```html
<div v-for="item in items" :key="item.id">
  <!-- content -->
</div>
```

반복되는 DOM 내용이 단순한 경우나 의도적인 성능 향상을 위해 기본 동작에 의존하지 않는 경우를 제외하면, 가능하면 언제나 v-for에 key를 추가하는 것이 좋다.

key는 Vue가 노드를 식별하는 일반적인 메커니즘이기 때문에 v-for와 특별히 연관되지 않는 다른 용도로도 사용된다.

## 배열 변경 감지

### 변이 메소드

Vue는 감시중인 배열의 변이 메소드를 래핑하여 뷰 갱신을 트리거한다.  
래핑된 메소드 종류

- push()
- pop()
- shift()
- unshift()
- splice()
- sort()
- reverse()

### 배열 교체

변이 메소드는 호출된 원래 배열을 변경한다.  
이에 비해 filter(), concat() 그리고 slice()와 같은 원래 배열을 변경하지 않지만 항상 새 배열을 반환하는 비-변이 메소드도 있다.  
비-변이 메소드로 작업할 때 이전 배열을 새 배열로 바꿀 수 있다.

이로 인해 Vue가 기존 DOM을 버리고 전체 목록을 다시 렌더링할 것이라고 생각할 수도 있으나 그렇지 않다.
Vue는 DOM 요소 재사용을 최대화하기 위해 몇 가지 smart heuristics을 구현하므로, 배열을 겹치는 객체를 포함하는 다른 배열로 교체하는 것은 매우 효율적인 작업이다.

## 필터링/정렬된 결과 표시

때때로 우리는 원래 데이터를 실제로 변경하거나 재설정하지 않고, 배열의 필터링되거나 정렬된 버전을 표시하려고 한다.  
이 경우 computed 속성을 만들 수 있다.

computed 속성이 실행 가능하지 않은 상황에서는 메소드를 사용할 수 있다.

## 범위가 있는 v-for

v-for도 정수를 사용할 수 있다.  
이 경우 템플릿을 여러 번 반복한다.

## \<template> 에서의 v-for

v-for와 함께 \<template> 태그를 사용하여 여러 요소의 블록을 렌더링할 수 있다.

## v-if가 있는 v-for

동일한 노드에 있는 경우, v-if는 v-for보다 우선 순위가 높다.
즉, v-if 조건은 v-for 범위의 변수에 접근할 수 없다.

```html
<li v-for="todo in todos" v-if="!todo.isComplete">
	{{ todo }}
</li>
```

v-if는 v-for보다 우선순위가 높으므로 v-if 문을 먼저 검사한다.
그렇게 되면 v-for에서 todos를 순회하며 붙인 별칭인 todo에 접근할 수 없게 된다.

v-for를 래핑하는 \<template> 태그를 사용하면 문제를 해결할 수 있다.

```html
<template v-for="todo in todos">
	<li v-if="!todo.isComplete">
  	{{ todo }}
  </li>
</template>
```

## 컴포넌트의 v-for

v-for를 사용자 정의 컴포넌트에 직접 사용할 수 있다.

그러나 컴포넌트에는 자체 범위가 분리되어 있기 때문에 컴포넌트에 데이터를 자동으로 전달하지 않는다.
반복할 데이터를 컴포넌트로 전달하려면 props도 사용해야 한다.

```html
<my-component
  v-for="(item, index) in items"
  :item="item"
  :index="index"
  :key="item.id"
></my-component>
```

item을 컴포넌트에 자동으로 삽입하지 않는 이유는 컴포넌트가 v-for 작동방식과 밀접하게 연결되어 있기 때문이다.  
데이터의 출처를 명시하면 다른 상황에서 컴포넌트를 재사용할 수 있다.